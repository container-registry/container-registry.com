<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><title>Lifting Developers’ Productivity with BuildKit CLI for kubectl - Container Registry</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=title property="og:title" content="Lifting Developers’ Productivity with BuildKit CLI for kubectl"><meta name=tags content="Developer,Productivity,Kubernetes,BuildKit,kubectl,Docker,Container,Kubernetes,Inner-loop,docker build"><meta name=twitter:title content="Lifting Developers’ Productivity - With BuildKit CLI for kubectl a drop in replacement for docker build"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@ContainerRgstry"><meta name=twitter:creator content="@weilun826"><meta name=twitter:image property="og:image" content="https://container-registry.com/posts/productivity-lift-buildkit-cli-for-kubectl/lifting-developers-productivity-with-buildkit-cli-for-kubectl-card.jpg"><link rel=icon href=https://container-registry.com/favicon.png><link rel=apple-touch-icon sizes=180x180 href=https://container-registry.com//favicon/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://container-registry.com//favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://container-registry.com//favicon/favicon-16x16.png><link rel=manifest href=https://container-registry.com//favicon/site.webmanifest><link rel=mask-icon href=https://container-registry.com//favicon/safari-pinned-tab.svg color=#5bbad5><link rel="shortcut icon" href=https://container-registry.com//favicon/favicon.ico><meta name=msapplication-TileColor content="#da532c"><meta name=msapplication-config content="https://container-registry.com//favicon/browserconfig.xml"><meta name=theme-color content="#ffffff"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@100;500&family=Open+Sans&display=swap" rel=stylesheet><link rel=stylesheet href=/css/style.min.777995b582eb859da1b8b41b0d53fee933d8b421f54d15ea2a8d4eff6b0cc768.css><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-P2NXZV4');</script></head><body class="page page-posts-single"><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P2NXZV4" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><div id=main-menu-mobile class=main-menu-mobile><ul><li class=menu-item-features><a href=/#features><span>Features</span></a></li><li class=menu-item-pricing><a href=/#pricing><span>Pricing</span></a></li><li class=menu-item-faq><a href=/faq/><span>FAQ</span></a></li><li class=menu-item-about><a href=/about/><span>About</span></a></li><li class=menu-item-blog><a href=/posts/><span>Blog</span></a></li><li class=menu-item-contact><a href=/contact/><span>Contact</span></a></li></ul></div><div id=header class="header header-fixed"><div class=container><div class=logos><div class=logo><a href=https://container-registry.com/><img height=70px width=70px alt="Container Registry Logo" src=/img/logo.svg></a></div><div class=logo-invert><a href=https://container-registry.com/><img height=70px width=70px alt="Container Registry Logo" src=/img/logo-white.svg></a></div><div class=logo-mobile><a href=https://container-registry.com/><img height=64px width=64px alt="Container Registry Logo" src=/img/logo.svg></a></div><div class=logo-invert-mobile><a href=https://container-registry.com/><img height=64px width=64px alt="Container Registry Logo" src=/img/logo-white.svg></a></div></div><div class=main-menu><ul><li class=menu-item-features><a href=/#features><span>Features</span></a><li class=menu-item-pricing><a href=/#pricing><span>Pricing</span></a><li class=menu-item-faq><a href=/faq/><span>FAQ</span></a><li class=menu-item-about><a href=/about/><span>About</span></a><li class=menu-item-blog><a href=/posts/><span>Blog</span></a><li class=menu-item-contact><a href=/contact/><span>Contact</span></a></ul></div><div id=toggle-main-menu-mobile class=menu-trigger><button class=hamburger>Menu</button></div></div></div><div id=wrapper class=wrapper><div class="hero hero-set-height" style=height:500px><div class=hero-image style="background-image:url(/posts/productivity-lift-buildkit-cli-for-kubectl/lifting-developers-productivity-with-buildkit-cli-for-kubectl.jpg),linear-gradient( to right,#00374D,#d03808 );background-blend-mode:overlay"><div class=container><div class=hero-text><h1 class=mb-1 style=color:#fff>Lifting Developers’ Productivity</h1><p style=color:#fff>With BuildKit CLI for kubectl a drop in replacement for docker build</p></div></div></div></div><div class="strip strip-white"><div class="container pt-4 pt-md-10 pb-4 pb-md-10"><div class="row justify-content-start"><div class="col-12 col-md-10 col-lg-8 col-xl-7"><div class="post post-single"><div class="content pb-5"><p>Developing and testing software on Kubernetes usually means building and moving container images from the developer workstation to a container registry, and ultimately, Kubernetes. When considering all the moving parts, the complexity and context switches break the development flow. Gone are the days where developers just hit a command and a few seconds later the newly built software is ready for testing.</p><p>What if there was some magical tool that you could simply feed instructions like: &ldquo;Build this Dockerfile <em>here</em> and replace any existing image on <em>that</em> Kubernetes cluster with the results!&rdquo; ASAP. Spoiler Alert! That is exactly what BuildKit CLI for kubectl is there to do.</p><p>Building container images with Docker is the typical method for most users, but it is not the only option to build container images. In situations in which the workload is already running in a container, like Docker, Kubernetes, CI/CD pipeline or a serverless function, it is not always possible to run Docker.</p><p>Where the required Docker features may not have been available historically, alternative approaches emerged that only replicated the required functionality. In this post, we not only introduce a unique method for building container images with BuildKit CLI for kubectl, but we will also discuss two solutions that are sure to save developers hours of time and a much cleaner CI/CD pipeline.</p><p>Before we dive into the details, let’s break down Docker into its different functionalities. Docker as an application serves multiple purposes and in essence is a monolithic application holding multiple functionalities. This overview shows Docker&rsquo;s functionalities and their single-purpose alternatives, allowing us to determine where BuildKit CLI for kubectl fits.</p><ul><li>Container engine: <a href=https://podman.io/>Podman</a></li><li>Container runtime: <a href=https://containerd.io/>containerd</a>, <a href=https://cri-o.io/>CRI-O</a></li><li>Image Build: <a href=https://github.com/moby/buildkit>BuildKit</a>, <a href=https://github.com/GoogleContainerTools/kaniko>Kaniko</a>, <a href=https://buildah.io/>Buildah</a></li><li>Inspection: <a href=https://github.com/wagoodman/dive>dive</a>, <a href=https://github.com/containers/skopeo>Skopeo</a></li></ul><p>Depending on the case, multiple single-purpose tools carved out of Docker exist that help replicate some needed Docker functionality. Even better, these tools usually work well together as <a href=https://opencontainers.org/>Open Container Initiative (OCI)</a>-conformant runtimes.</p><h2 id=buildkit-cli-for-kubectl>BuildKit CLI for kubectl</h2><p><a href=https://github.com/vmware-tanzu/buildkit-cli-for-kubectl>BuildKit CLI for kubectl</a> is a plugin for kubectl the Kubernetes command-line tool. The plugin extends the functionality of kubectl, allowing to build container images without a local Docker installation.</p><p>VMware <a href=https://blogs.vmware.com/opensource/2020/11/17/buildkit-cli-for-kubectl/>open sourced</a> BuildKit CLI for kubectl in 2020. The initial product announcement sums up pretty well the purpose of the tool:</p><blockquote><p>A key feature of this new tool is that it strives to make the images you build immediately available in the container runtime of your Kubernetes cluster so you can “bounce” your pod(s) to pick up a freshly built image with virtually no overhead.</p></blockquote><p>BuildKit CLI for kubectl has the following key features:</p><ul><li>Dockerfiles are parsed the same way as with the existing <code>docker build</code></li><li>Container images are built within Kubernetes, to leverage the power of your Kubernetes cluster</li><li>Builds OCI compatible images</li><li><a href=https://github.com/vmware-tanzu/buildkit-cli-for-kubectl/blob/main/docs/multiarch.md>Supports building multi-architecture images</a></li><li>No local registry needed for local Kubernetes development</li></ul><h2 id=inner-loop-productivity-flow>Inner-Loop Productivity Flow</h2><p>As developers, we spend a significant amount of time in the so-called &ldquo;Inner Loop.&rdquo; This is an iterative process where code is written, built, and tested repeatedly. All this takes place before we share our work with the team and the rest of the world, hence the need for code reviews and a CI workflow prior to pushing our completed work. The tight loop is the productive phase of the development process, therefore we want to spend as much time in the iterations as possible.</p><p>Iterations should be fast and with minimal friction. For example, if it takes 30 minutes to complete one loop, we can average around 10-12 loops a day. By shrinking that time to three minutes, we can theoretically make over 100 iterations of writing and testing code in a single day. That&rsquo;s a huge productivity boost without &ldquo;context switches&rdquo; while waiting for your code to compile and deploy.</p><p>Mitch Denny has written an accurate <a href=https://web.archive.org/web/20201107102000/https://mitchdenny.com/the-inner-loop/>summary about the inner-loop</a> and how to tune it.<br><figure><img src=/posts/productivity-lift-buildkit-cli-for-kubectl/Inner-loop-outer-loop.svg alt="Inner Loop and outer Loop Development Workflow" width=100%></figure></p><p>There are two ways to speed up the inner-loop. More hardware power to reduce the time it takes to build and deploy, or take some shortcuts by skiping steps in the cycle. BuildKit CLI for kubectl falls into the latter category. It allows us to skip superfluous steps, allowing us to reduce context switches to decrease wait time resulting in more iterations. The diagram above illustrates the two methods of deploying an application to Kubernetes. The common practice today is:</p><ul><li>Compile the code and package the artifacts</li><li>Build the container image locally</li><li>Push the container image to a container registry</li><li>Execute the deployment</li><li>Let Kubernetes pull the container image from the container registry</li><li>Start the application</li></ul><p>With BuildKit CLI for kubectl, the need to repeat all the steps every time we want to test our changes is no longer there. After the initial full cycle we only need our Kubernetes cluster to build the new image and restart the pods requiring updates. By mastering the lean image build workflow, it all should take less than a few seconds.</p><p><figure><img src=/posts/productivity-lift-buildkit-cli-for-kubectl/workflow-with-buildkit-cli-for-kubectl.svg alt="Common practice workflow with and without BuildKit CLI for kubectl" width=100%></figure>Enough theory! Let us examine this workflow in practice and replace our local <code>docker build</code> with <code>kubectl build</code> for our Kubernetes development workflow.</p><h2 id=installation>Installation</h2><p>Download the binaries for your platform from github on <a href=https://github.com/vmware-tanzu/buildkit-cli-for-kubectl/releases>vmware-tanzu/buildkit-cli-for-kubectl/releases</a>.</p><p>The best way to work with kubectl plugins is to use <a href=https://krew.sigs.k8s.io/>Krew</a> the plugin manager for kubectl. Unfortunately, at the moment of writing, buildkit-cli-for-kubectl is <a href=https://github.com/vmware-tanzu/buildkit-cli-for-kubectl/issues/5>not supported yet</a>. Once the buildkit-cli-for-kubectl Krew plugin is available, the installation will be simple:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl krew install buildkit-cli-for-kubectl
</code></pre></div><p>After downloading the binary for and extracting it:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>cat darwin-*.tgz | tar -C /usr/local/bin -xvf -
<span style=color:#75715e>#This is an example for MacOS &amp; Linux</span>
</code></pre></div><p>We can verify the successful installation and the plugin registration with <code>kubectl</code></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl build --help
or
kubectl buildkit --help
</code></pre></div><p>The buildkit-cli-for-kubectl package contains two binaries: <code>buildkit</code> and <code>build</code> which is simply an alias for <code>buildkit build</code>.
Now that we have installed buildkit-cli-for-kubectl and verified its functionality, we can try to make something useful.</p><h2 id=example-application>Example Application</h2><p>For our example, we are going to use a simple Hello-World Go application. There is no need to install anything locally as the Golang toolset, and everything needed is within the Dockerfile.</p><p>Clone the minimum Hello-World application from <a href=https://github.com/container-registry/buildkit-cli-for-kubectl-demo-app>buildkit-cli-for-kubectl-demo-app</a></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>git clone https://github.com/container-registry/buildkit-cli-for-kubectl-demo-app.git
cd buildkit-cli-for-kubectl-demo-app
</code></pre></div><h3 id=building-an-image-with-buildkit-cli-for-kubectl>Building an Image with BuildKit CLI for kubectl</h3><p>To build container images, we need to have a Kubernetes cluster up and running. One easy option to set up a local Kubernetes cluster it to use <a href=https://minikube.sigs.k8s.io/>minikube</a> or <a href=https://k3d.io/>k3d</a>. Note that k3d needs <a href=https://github.com/vmware-tanzu/buildkit-cli-for-kubectl/blob/main/docs/installing.md#k3d>a workaround</a>.</p><p>To build a Container Image with BuildKit CLI for kubectl simply run:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl build -t hello-world -f Dockerfile .
</code></pre></div><p>The CLI build syntax is the same as Docker build.
In this example, the first built took around ~70 seconds, which is not very impressive to be considered a quick iteration.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ kubectl build -t 8gears.container-registry.com/examples/hello-world -f Dockerfile .
<span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Building 69.2s <span style=color:#f92672>(</span>17/17<span style=color:#f92672>)</span> FINISHED                                                                                                                                                                       
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>[</span>internal<span style=color:#f92672>]</span> booting buildkit
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>=</span>&gt; waiting <span style=color:#66d9ef>for</span> <span style=color:#ae81ff>1</span> pods to be ready 
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>[</span>internal<span style=color:#f92672>]</span> load build definition from Dockerfile
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>=</span>&gt; transferring dockerfile: 501B
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>[</span>internal<span style=color:#f92672>]</span> load .dockerignore
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>=</span>&gt; transferring context: 2B 
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>[</span>internal<span style=color:#f92672>]</span> load metadata <span style=color:#66d9ef>for</span> docker.io/library/alpine:latest
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>[</span>internal<span style=color:#f92672>]</span> load metadata <span style=color:#66d9ef>for</span> docker.io/library/golang:latest
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>[</span>stage-1 1/4<span style=color:#f92672>]</span> FROM 
...
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>[</span>builder 1/5<span style=color:#f92672>]</span> FROM 
...
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>[</span>stage-1 2/4<span style=color:#f92672>]</span> RUN addgroup -S example-group <span style=color:#f92672>&amp;&amp;</span> adduser -S -D example -G example-group
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>[</span>stage-1 3/4<span style=color:#f92672>]</span> WORKDIR /home/example
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>[</span>builder 2/5<span style=color:#f92672>]</span> WORKDIR /hello-world
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>[</span>builder 3/5<span style=color:#f92672>]</span> COPY go.mod .
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>[</span>builder 4/5<span style=color:#f92672>]</span> COPY . .
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>[</span>builder 5/5<span style=color:#f92672>]</span> RUN CGO_ENABLED<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span> GOOS<span style=color:#f92672>=</span>linux GOARCH<span style=color:#f92672>=</span>amd64 go build -o /bin/hello-world .
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>[</span>stage-1 4/4<span style=color:#f92672>]</span> COPY --from<span style=color:#f92672>=</span>builder /bin/hello-world ./
 <span style=color:#f92672>=</span>&gt; exporting to oci image format
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>=</span>&gt; exporting layers
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>=</span>&gt; exporting manifest sha256:...
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>=</span>&gt; exporting config sha256:...
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>=</span>&gt; sending tarball
 <span style=color:#f92672>=</span>&gt; loading image to docker runtime via pod buildkit-55fbd66677-m9v56  
</code></pre></div><p>However, the subsequent runs become much faster. This Kubernetes cluster can finish the build in 3.2 seconds, which is abut enough time to switch from the IDE to browser and hit refresh.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ kubectl build -t 8gears.container-registry.com/examples/hello-world -f Dockerfile .
<span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Building 3.2s <span style=color:#f92672>(</span>16/16<span style=color:#f92672>)</span> FINISHED
</code></pre></div><p>We can also see a BuildKit deployment in our cluster.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ kubectl get deploy

NAME             READY   UP-TO-DATE   AVAILABLE   AGE
buildkit         1/1     <span style=color:#ae81ff>1</span>            <span style=color:#ae81ff>1</span>           2m
</code></pre></div><blockquote><p>You would have to <a href=https://minikube.sigs.k8s.io/docs/handbook/registry/>enable registry</a> or <a href=https://stackoverflow.com/questions/42564058/how-to-use-local-docker-images-with-minikube>use some hack</a> to use local build image with Minikube. With BuildKit CLI for kubectl, this is optional.</p></blockquote><h3 id=deploying-an-application>Deploying an Application</h3><p>In the previous step, we only built a container image on remote Kubernetes cluster but never utilized it. A container image in a resting state like this within the Kubernetes cluster is quite useless. To prove that we can achieve a quick inner-loop cycle, let us deploy the hello-world application and measure how long it takes to get our change appear in the cluster.</p><p>The initial deployment:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ kubectl apply -f deployment.yaml

deployment.apps/hello-world created
service/hello-world created
</code></pre></div><p>We can first verify the application deployment:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ kubectl get deploy,svc

NAME                          READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/buildkit      1/1     <span style=color:#ae81ff>1</span>            <span style=color:#ae81ff>1</span>           36m
deployment.apps/hello-world   1/1     <span style=color:#ae81ff>1</span>            <span style=color:#ae81ff>1</span>           4m19s

NAME                  TYPE        CLUSTER-IP     EXTERNAL-IP   PORT<span style=color:#f92672>(</span>S<span style=color:#f92672>)</span>   AGE
service/hello-world   ClusterIP   10.39.140.45   &lt;none&gt;        80/TCP    4m18s
</code></pre></div><p>To verify the application itself, we can bypass the ingress or load balancer with the <code>kubectl port-forward</code> and forward our local ports <code>8081</code> to the remote service port <code>80</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ kubectl port-forward service/hello-world 8081:80  

Forwarding from 127.0.0.1:8081 -&gt; <span style=color:#ae81ff>8080</span>
Forwarding from <span style=color:#f92672>[</span>::1<span style=color:#f92672>]</span>:8081 -&gt; <span style=color:#ae81ff>8080</span>

<span style=color:#75715e># Open a second terminal and verify that the application responds.  </span>
$ curl localhost:8081

Hello, world!
Version: 1.0.0
Hostname: hello-world-d8b44fbff-pt2bm
</code></pre></div><p>Now that we verified our application is up and running, we can change our code and measure how long it takes to notice the change in the cluster.
Perform minor code change in the <code>main.go</code> file.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#75715e>//Change in Line 26 
</span><span style=color:#75715e></span><span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintf</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Hello, reader!\n&#34;</span>)
</code></pre></div><p>Lets measure the time it takes:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>time <span style=color:#f92672>(</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>kubectl build -t 8gears.container-registry.com/examples/hello-world:latest -f Dockerfile . <span style=color:#f92672>&amp;&amp;</span><span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>kubectl rollout restart deployment/hello-buildkit-example <span style=color:#f92672>&amp;&amp;</span><span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>kubectl rollout status deployment/hello-buildkit-example <span style=color:#f92672>&amp;&amp;</span><span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>curl --retry <span style=color:#ae81ff>5</span> 52.42.1.123:30080
<span style=color:#f92672>)</span>
</code></pre></div><p>The result is that the code change made it into our Kubernetes Cluster within 13 seconds.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#f92672>[</span>+<span style=color:#f92672>]</span> Building 4.1s <span style=color:#f92672>(</span>14/14<span style=color:#f92672>)</span> FINISHED
 <span style=color:#f92672>=</span>&gt; <span style=color:#f92672>[</span>internal<span style=color:#f92672>]</span> load build definition from Dockerfile
 .....
 <span style=color:#f92672>=</span>&gt; loading image to docker runtime via pod buildkit-7f7bf48987-brc2r
deployment.apps/hello-buildkit-example restarted
Waiting <span style=color:#66d9ef>for</span> deployment <span style=color:#e6db74>&#34;hello-buildkit-example&#34;</span> rollout to finish: <span style=color:#ae81ff>1</span> old replicas are pending termination...
deployment <span style=color:#e6db74>&#34;hello-buildkit-example&#34;</span> successfully rolled out
Hello, reader!
Version: 1.0.0
Hostname: hello-buildkit-example-78894bfbfc-rnz4p

0.72s user 0.43s system 5% cpu 12.918 total

</code></pre></div><p>Is 13 seconds much faster than the traditional way? Well, it depends on a few factors:</p><ul><li>Container Image size: Larger container images take more time to up and download to the container registry.</li><li>Kubernetes deployment stack complexity with multiple pods, services and other resources takes more time to update.</li><li>Container Build time is CPU and IO intense and is usually faster on server hardware.</li></ul><p>Deploying the same application, the traditional way takes about 33 seconds.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>time docker build -t 8gears.container-registry.com/examples/hello-world:latest -f   
0.26s user 0.18s system 3% cpu 13.529 total

time docker push 8gears.container-registry.com/examples/hello-world:latest  
0.17s user 0.11s system 2% cpu 11.789 total

time kubectl apply -f deployment.yaml <span style=color:#f92672>&amp;&amp;</span> kubectl rollout status  <span style=color:#f92672>&amp;&amp;</span> curl 52.42.1.123:30080
0.43s user 0.18s system 6% cpu 8.700 total

</code></pre></div><p>Even with this sample application, there is already a 66 % time improvement. With real-life scenarios and complex application stacks, the time saving is even bigger. No more waiting and context switches for minutes until the changes reach our Kubernetes cluster.</p><p>Now that we are using BuildKit CLI for kubectl, we don&rsquo;t even have to change our deployment or Helm Charts with correct image tags. In addition, we can also skip cleaning up our polluted container registry or set up a retention policy.</p><p>Because there are much less moving parts, it becomes easier to create a workflow that automatically rebuilds and redeploys our changes whenever our code changes.</p><h2 id=what-more-is-possible-with-buildkit-cli-for-kubectl>What more is possible with BuildKit CLI for kubectl?</h2><p>BuildKit CLI for kubectl also works great with container registries. We can, for example, push the built images to our <a href=https://container-registry.com/>container-registry</a> or <a href=https://c8n.io>c8n</a>. A secret can be obtained from our c8n.io container registry under: User Profile -> CLI secret. Here, you will create a Kubernetes container registry secret that will be used to pull/push the image.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl create secret docker-registry c8n-secret <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span> --docker-server<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;c8n.io&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span> --docker-username<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;USER_NAME_CASE_SENTITIVE&#39;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span> --docker-password<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;REG_SECRET&#39;</span>

<span style=color:#75715e># Verify the secret was created:</span>
kubectl get secret c8n-secret
</code></pre></div><h3 id=build-and-push-container-image-with-buildkit-cli-for-kubectl>Build and Push Container Image with BuildKit CLI for kubectl</h3><p>BuildKit CLI for kubectl can also push image after creating them by appending the <code>--push</code> and <code>--registry-secret</code> flags to the <code>build</code> command accordingly:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl build --push --registry-secret c8n-secret <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -t c8n.io/USER_NAME/hello-world:1.0 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  -f Dockerfile .

</code></pre></div><h3 id=change-deployment-to-use-our-private-registry>Change Deployment to use our Private Registry</h3><p>There are <a href=https://kubernetes.io/docs/concepts/containers/images/#using-a-private-registry>a few approaches</a> on how to access a private container registry in Kubernetes. An elegant solution that doesn&rsquo;t require changing the deployment is to <a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>add ImagePullSecrets to a service account</a>.</p><p>We can reuse our created imagePullSecret from before and attach it to the service account.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># update service account for all deployments to use image pull secret</span>
kubectl patch serviceaccount default -p <span style=color:#e6db74>&#39;{&#34;imagePullSecrets&#34;: [{&#34;name&#34;: &#34;registry-secret&#34;}]}&#39;</span>
</code></pre></div><h4 id=update-deployment>update deployment</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
...
<span style=color:#f92672>spec</span>:
  <span style=color:#ae81ff>...</span>
  <span style=color:#f92672>template</span>:
    <span style=color:#ae81ff>...</span>
    <span style=color:#f92672>spec</span>:
      <span style=color:#f92672>containers</span>:
          - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>hello-buildkit-example</span>
            <span style=color:#f92672>image</span>: <span style=color:#ae81ff>c8n.io/user_name/hello-world:1.0</span> <span style=color:#75715e># use private registry</span>
            <span style=color:#ae81ff>...</span>
</code></pre></div><p>Redeploy the updated <code>deployment.yaml</code> file to let Kubernetes pull the image from our private container registry.</p><h2 id=closing-thoughts>Closing Thoughts</h2><p>BuildKit CLI for kubectl is highly valuable when developing software on a local or remote Kubernetes cluster. Docker is intense on CPU and I/O usage while building images, making everything perform more sluggish. In situations like this, we usually tend to just to wait until the build finishes, which breaks our workflow and slows down our inner-loop cycle.
The <a href=https://www.docker.com/blog/how-to-deploy-on-remote-docker-hosts-with-docker-compose>Docker remote host</a> feature is an alternative but requires a provisioned VM with its own setup and maintenance overhead. Since we already work with Kubernetes, BuildKit CLI for kubectl is the perfect fit. It allows us to make deployment shortcuts and use the superior processing power of our Kubernetes cluster.</p><p>It is extremely easy to get started with BuildKit CLI for kubectl by using it as a drop-in replacement for <code>docker build</code>. This provides those who use it a way to take shortcuts without the need of two separate workflows for the inner and outer loop.</p><p>While still in <a href=https://github.com/vmware-tanzu/buildkit-cli-for-kubectl/releases>pre-release</a> it is already showing a large amount of downloads and is considered stable for use. Try it out the next time you need to wait for your changes to reach your Kubernetes cluster.</p><div class="col-12 pt-5"><div class="team team-summary"><div class=team-image><img alt="Container Registry logo" class=img-fluid src=/img/logo.svg></div><div class=team-block><div class=team-meta><h3 class=team-name>Container Management Solution for Organizations</h3></div><div class=team-content><p>A Container Management Solution that was made for Kubernetes</p></div><a id=hero-cta-button href=/#pricing-title class="button button-secondary mt-1 btn-md text-center" style=text-decoration:none>Discover our offer</a></div></div></div></div><div class="pt-1 pb-4"><p><strong>Published</strong> — January 7, 2021</p></div><div class=post-author><div class=post-author-avatar><img src=https://container-registry.com/team/weilun.jpg alt></div><div class=post-author-info><a class=post-author-name href=https://container-registry.com/authors/yong-wei-lun/>Yong Wei Lun</a>
<span class=post-author-date>Jan 7, 2021</span></div></div><div class=post-author><div class=post-author-avatar><img src=https://container-registry.com/team/Vadim-Bauer-2020-BW.jpg alt></div><div class=post-author-info><a class=post-author-name href=https://container-registry.com/authors/vadim-bauer/>Vadim Bauer</a>
<span class=post-author-date>Feb 7, 2021</span></div></div><div class=post-tags><strong>Tags:</strong>
<a class=post-tag href=/tags/buildkit>BuildKit</a>
<a class=post-tag href=/tags/kubectl>kubectl</a>
<a class=post-tag href=/tags/docker>Docker</a>
<a class=post-tag href=/tags/container>Container</a>
<a class=post-tag href=/tags/kubernetes>Kubernetes</a>
<a class=post-tag href=/tags/inner-loop>Inner-loop</a>
<a class=post-tag href=/tags/docker-build>docker build</a></div><div class=post-categories><strong>Categories:</strong>
<a class=post-category href=/categories/developer>Developer</a>
<a class=post-category href=/categories/productivity>Productivity</a>
<a class=post-category href=/categories/kubernetes>Kubernetes</a></div></div></div></div></div></div></div><div class=footer><div class=container><div class=row><div class=col-12><h3 class=footer-title>Container Registry</h3></div></div></div></div><div class=footer-second><div class=container><div class=row><div class=col-12><div class=footer-second-menu><div class=row><div class="col-12 col-md-3"><h3>Site</h3><div class=menu-footer-primary><ul><li class=menu-item-home><a href=/><span>Home</span></a></li><li class=menu-item-features><a href=/#features><span>Features</span></a></li><li class=menu-item-pricing><a href=/#pricing><span>Pricing</span></a></li><li class=menu-item-contact><a href=/contact/><span>Contact</span></a></li></ul></div></div><div class="col-12 col-md-3"><h3>Services</h3><div class=menu-footer-secondary><ul><li class="menu-item-customer portal"><a id=customer-portal href=javascript:void(0) data-billsby-type=account>Customer Portal</a></li><li class="menu-item-c8n free regsitry"><a href=https://c8n.io><span>C8N Free Regsitry</span></a></li></ul></div></div><div class="col-12 col-md-3"><h3>Support</h3><div class=menu-footer-secondary><ul><li class="menu-item-privacy policy"><a href=/privacy/><span>Privacy Policy</span></a></li><li class="menu-item-terms of service"><a href=/terms-of-service/><span>Terms of Service</span></a></li></ul></div></div><div class="col-12 col-md-3"><h3>Social</h3><div class=menu-footer-social><ul class=d-flex><li class="menu-item-social mr-1"><a href=https://twitter.com/ContainerRgstry target=_blank><i class="fab fa-twitter"></i></a></li><li class="menu-item-social mr-1"><a href=https://www.reddit.com/r/docker/ target=_blank><i class="fab fa-reddit-alien"></i></a></li><li class="menu-item-social mr-1"><a href=https://www.linkedin.com/showcase/container-registry target=_blank><i class="fab fa-linkedin"></i></a></li><li class="menu-item-social mr-1"><a href=/contact/ target=_blank><i class="fa fa-envelope"></i></a></li></ul></div></div></div></div></div></div></div></div><div class=footer-third><div class=container><div class=row><div class=col-12><div class=text-white>©Copyright - Container Registry by 8gears Ltd</div></div></div></div></div><script type=text/javascript src=/js/bundle.min.c6e1dc68ac8126c9f5e65662799e3e0abf809533c70a58bcff1dded8e80d2f1b.js></script><script async src=https://unpkg.com/feather-icons></script><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><script>feather.replace()</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-179953813-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-179953813-1',{'link_attribution':true});</script><script type=text/javascript id=hs-script-loader async src=//js.hs-scripts.com/7006577.js></script></body></html>